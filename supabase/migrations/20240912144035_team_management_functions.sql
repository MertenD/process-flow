CREATE OR REPLACE FUNCTION public.add_role(name_param text, color_param text, belongs_to_param bigint)
    RETURNS bigint
    LANGUAGE plpgsql
AS $function$DECLARE
    role_id bigint;
BEGIN
    -- Check if it already exists
    IF EXISTS (SELECT 1 FROM role WHERE name = name_param AND belongs_to = belongs_to_param) THEN
        RAISE EXCEPTION 'Role with name % already exists in team.', name_param;
    END IF;

    INSERT INTO role (name, color, belongs_to)
    VALUES (name_param, color_param, belongs_to_param)
    RETURNING id INTO role_id;

    RETURN role_id;
END;$function$;

CREATE OR REPLACE FUNCTION public.remove_role(role_id bigint)
    RETURNS void
    LANGUAGE plpgsql
AS $function$BEGIN
    DELETE FROM role
    WHERE id = role_id;
END;$function$;

CREATE OR REPLACE FUNCTION public.update_profiles_roles_in_team(team_id_param bigint, profile_id_param uuid, role_ids_param bigint[])
    RETURNS void
    LANGUAGE plpgsql
AS $function$BEGIN
    DELETE FROM profile_role_team
    WHERE team_id = team_id_param AND profile_id = profile_id_param AND role_id NOT IN (SELECT unnest(role_ids_param));

    INSERT INTO profile_role_team (team_id, profile_id, role_id)
    SELECT team_id_param, profile_id_param, role_id
    FROM unnest(role_ids_param) AS role_id
    ON CONFLICT (team_id, profile_id, role_id) DO NOTHING;
END;$function$;

CREATE TABLE public.profile_team (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone not null default now(),
    profile_id uuid NOT NULL REFERENCES profiles(id),
    team_id bigint NOT NULL REFERENCES team(id)
);

CREATE OR REPLACE FUNCTION public.add_profile_to_team(profile_id_param bigint, team_id_param bigint)
    RETURNS void
    LANGUAGE plpgsql
AS $function$BEGIN
    -- Check if it already exists
    IF EXISTS (SELECT 1 FROM profile_team WHERE profile_id = profile_id_param AND team_id = team_id_param) THEN
        RAISE EXCEPTION 'Profile with id % already exists in team with id %.', profile_id_param, team_id_param;
    END IF;

    INSERT INTO profile_team (profile_id, team_id)
    VALUES (profile_id_param, team_id_param)
    ON CONFLICT DO NOTHING;
END;$function$;

CREATE OR REPLACE FUNCTION public.remove_profile_from_team(profile_id_param bigint, team_id_param bigint)
    RETURNS void
    LANGUAGE plpgsql
AS $function$BEGIN
    DELETE FROM profile_team
    WHERE profile_id = profile_id_param AND team_id = team_id_param;
END;$function$;

CREATE TABLE public.invitation (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone not null default now(),
    email text NOT NULL,
    team_id bigint NOT NULL REFERENCES team(id)
);

-- Accept invite function that adds the user to the team and deletes the invitation
CREATE OR REPLACE FUNCTION public.accept_invite(invitation_id_param bigint, profile_id_param bigint)
    RETURNS void
    LANGUAGE plpgsql
AS $function$BEGIN
    -- Check if the invitation exists
    IF NOT EXISTS (SELECT 1 FROM invitation WHERE id = invitation_id_param) THEN
        RAISE EXCEPTION 'Invitation with id % does not exist.', invitation_id_param;
    END IF;

    -- Check if the profile is already in the team
    IF EXISTS (SELECT 1 FROM profile_team WHERE profile_id = profile_id_param AND team_id = (SELECT team_id FROM invitation WHERE id = invitation_id_param)) THEN
        RAISE EXCEPTION 'Profile with id % is already in the team.', profile_id_param;
    END IF;

    -- Check if the given profile has the same email as the invitation
    IF NOT EXISTS (SELECT 1 FROM profiles WHERE id = profile_id_param AND email = (SELECT email FROM invitation WHERE id = invitation_id_param)) THEN
        RAISE EXCEPTION 'Profile with id % does not have the same email as the invitation.', profile_id_param;
    END IF;

    INSERT INTO profile_team (profile_id, team_id)
    SELECT profile_id_param, team_id
    FROM invitation
    WHERE id = invitation_id_param;

    DELETE FROM invitation
    WHERE id = invitation_id_param;
END;$function$;

-- Create invitation it it does not exist yet
CREATE OR REPLACE FUNCTION public.create_invite(email_param text, team_id_param bigint)
    RETURNS bigint
    LANGUAGE plpgsql
AS $function$DECLARE
    invitation_id bigint;
BEGIN
    -- Check if the email is already in the team
    IF EXISTS (SELECT 1 FROM profiles WHERE email = email_param AND id IN (SELECT profile_id FROM profile_team WHERE team_id = team_id_param)) THEN
        RAISE EXCEPTION 'Email % is already in the team.', email_param;
    END IF;

    -- Check if the email is already invited
    IF EXISTS (SELECT 1 FROM invitation WHERE email = email_param AND team_id = team_id_param) THEN
        RAISE EXCEPTION 'Email % is already invited.', email_param;
    END IF;

    INSERT INTO invitation (email, team_id)
    VALUES (email_param, team_id_param)
    RETURNING id INTO invitation_id;

    RETURN invitation_id;
END;$function$;

CREATE OR REPLACE VIEW public.profiles_with_roles AS
SELECT profiles.id AS profile_id,
       profiles.email,
       profiles.username,
       profile_team.team_id,
       role.id AS role_id,
       role.name AS role_name,
       role.color AS role_color
FROM profile_team
         JOIN profiles ON profiles.id = profile_team.profile_id
         LEFT JOIN profile_role_team ON profile_team.team_id = profile_role_team.team_id AND profile_team.profile_id = profile_role_team.profile_id
         LEFT JOIN role ON profile_role_team.role_id = role.id;

CREATE UNIQUE INDEX unique_profile_role_team ON profile_role_team (profile_id, role_id, team_id);

-------------------------
-- Automatic from db diff

drop policy "Enable read access for all users" on "public"."profiles";

alter table "public"."profile_role_team" drop constraint "public_profile_role_team_role_fkey";

drop function if exists "public"."create_invite"(email_param text, team_id_param bigint);

drop function if exists "public"."create_team_and_add_creator_as_admin"(creator_profile_id uuid, team_name text);

alter table "public"."invitation" enable row level security;

alter table "public"."profile_team" enable row level security;

alter table "public"."role" alter column "color" set not null;

CREATE UNIQUE INDEX invitation_pkey ON public.invitation USING btree (id);

alter table "public"."invitation" add constraint "invitation_pkey" PRIMARY KEY using index "invitation_pkey";

alter table "public"."profile_role_team" add constraint "public_profile_role_team_role_id_fkey" FOREIGN KEY (role_id) REFERENCES role(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profile_role_team" validate constraint "public_profile_role_team_role_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_invitation(email_param text, team_id_param bigint)
    RETURNS bigint
    LANGUAGE plpgsql
AS $function$DECLARE
    invitation_id bigint;
BEGIN
    -- Check if the email is already in the team
    IF EXISTS (SELECT 1 FROM profiles WHERE email = email_param AND id IN (SELECT profile_id FROM profile_team WHERE team_id = team_id_param)) THEN
        RAISE EXCEPTION 'Email % is already in the team.', email_param;
    END IF;

    -- Check if the email is already invited
    IF EXISTS (SELECT 1 FROM invitation WHERE email = email_param AND team_id = team_id_param) THEN
        RAISE EXCEPTION 'Email % is already invited.', email_param;
    END IF;

    INSERT INTO invitation (email, team_id)
    VALUES (email_param, team_id_param)
    RETURNING id INTO invitation_id;

    RETURN invitation_id;
END;$function$
;

create policy "grant access to delete own invitation"
    on "public"."invitation"
    as permissive
    for delete
    to authenticated
    using ((( SELECT profiles.email
              FROM profiles
              WHERE (profiles.id = auth.uid())) = email));


create policy "grant access to only create for authenticated"
    on "public"."invitation"
    as permissive
    for insert
    to authenticated
    with check (true);


create policy "grant read access for own invitations"
    on "public"."invitation"
    as permissive
    for select
    to authenticated
    using (true);


create policy "enable delte for authenticated user"
    on "public"."profile_role_team"
    as permissive
    for delete
    to authenticated
    using (true);


create policy "grant access to do all to everybody"
    on "public"."profile_team"
    as permissive
    for all
    to authenticated
    using (true);


create policy "enable delete for everybody"
    on "public"."role"
    as permissive
    for delete
    to authenticated
    using ((belongs_to IN ( SELECT prt.team_id
                            FROM (profile_role_team prt
                                JOIN role role_1 ON ((role_1.id = prt.role_id)))
                            WHERE ((role_1.name = 'admin'::text) AND (prt.profile_id = auth.uid())))));


create policy "enable update for authenticated users"
    on "public"."role"
    as permissive
    for update
    to authenticated
    using (true);


create policy "Enable read access for all users"
    on "public"."profiles"
    as permissive
    for select
    to authenticated
    using (true);
