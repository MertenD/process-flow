drop view if exists "public"."manual_task";

alter type "public"."node_type" rename to "node_type__old_version_to_be_dropped";

create type "public"."node_type" as enum ('challengeNode', 'activityNode', 'gatewayNode', 'startNode', 'endNode', 'infoNode', 'gamificationEventNode', 'andSplitNode', 'andJoinNode');

create table "public"."and_split_element" (
                                              "id" bigint generated by default as identity not null,
                                              "created_at" timestamp with time zone not null default now(),
                                              "flow_element_id" bigint not null,
                                              "next_flow_element_id_1" bigint,
                                              "next_flow_element_id_2" bigint
);


alter table "public"."and_split_element" enable row level security;

alter table "public"."flow_element" alter column type type "public"."node_type" using type::text::"public"."node_type";

drop type "public"."node_type__old_version_to_be_dropped";

CREATE UNIQUE INDEX and_split_element_flow_element_id_key ON public.and_split_element USING btree (flow_element_id);

CREATE UNIQUE INDEX and_split_element_pkey ON public.and_split_element USING btree (id);

alter table "public"."and_split_element" add constraint "and_split_element_pkey" PRIMARY KEY using index "and_split_element_pkey";

alter table "public"."and_split_element" add constraint "and_split_element_flow_element_id_key" UNIQUE using index "and_split_element_flow_element_id_key";

alter table "public"."and_split_element" add constraint "public_and_split_element_flow_element_id_fkey" FOREIGN KEY (flow_element_id) REFERENCES flow_element(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."and_split_element" validate constraint "public_and_split_element_flow_element_id_fkey";

alter table "public"."and_split_element" add constraint "public_and_split_element_next_flow_element_id_1_fkey" FOREIGN KEY (next_flow_element_id_1) REFERENCES flow_element(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."and_split_element" validate constraint "public_and_split_element_next_flow_element_id_1_fkey";

alter table "public"."and_split_element" add constraint "public_and_split_element_next_flow_element_id_2_fkey" FOREIGN KEY (next_flow_element_id_2) REFERENCES flow_element(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."and_split_element" validate constraint "public_and_split_element_next_flow_element_id_2_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_next_flow_element_instance()
    RETURNS trigger
    LANGUAGE plpgsql
AS $function$DECLARE
    current_flow_element_type text;
    current_flow_element_data jsonb;
    next_flow_element_id_first int8;
    next_flow_element_id_second int8;
    gateway_flow_element_next_true_id int8;
    gateway_flow_element_next_false_id int8;
BEGIN

    -- check if instance is indeed done
    IF NEW.status != 'Completed' THEN
        RAISE EXCEPTION 'Previous flow element instance is not completed yet. Current status: %', NEW.status;
    END IF;

    -- Get the type of the flow element that that the flow element instance that triggered this function is an instance of
    SELECT type INTO current_flow_element_type
    FROM flow_element
    WHERE id = NEW.instance_of;

    -- Get the next flow element id. It is different for each flow element type
    CASE
        WHEN current_flow_element_type = 'startNode' THEN
            SELECT start_element.next_flow_element_id INTO next_flow_element_id_first
            FROM start_element
            WHERE flow_element_id = NEW.instance_of;
        WHEN current_flow_element_type = 'activityNode' THEN
            SELECT activity_element.next_flow_element_id INTO next_flow_element_id_first
            FROM activity_element
            WHERE flow_element_id = NEW.instance_of;
        WHEN current_flow_element_type = 'gatewayNode' THEN

            -- Get gateway data
            SELECT data INTO current_flow_element_data
            FROM flow_element
            WHERE id = NEW.instance_of;

            -- Get the next flow element id from the gateway flow element
            SELECT next_flow_element_true_id, next_flow_element_false_id INTO gateway_flow_element_next_true_id, gateway_flow_element_next_false_id
            FROM gateway_element
            WHERE flow_element_id = NEW.instance_of;

            -- Replace variables in the data object with the actual values
            current_flow_element_data := replace_with_variable_values(current_flow_element_data, NEW.is_part_of);

            -- Evaluate the gateway expression
            SELECT CASE
                       WHEN current_flow_element_data->>'comparison' = '==' THEN
                           CASE
                               WHEN (
                                        SELECT array_agg(value ORDER BY value)
                                        FROM unnest(string_to_array(current_flow_element_data->>'value1', ',')) AS value
                                    ) = (
                                        SELECT array_agg(value ORDER BY value)
                                        FROM unnest(string_to_array(current_flow_element_data->>'value2', ',')) AS value
                                    ) THEN
                                   gateway_flow_element_next_true_id
                               ELSE
                                   gateway_flow_element_next_false_id
                               END
                       WHEN current_flow_element_data->>'comparison' = '!=' THEN
                           CASE
                               WHEN (
                                        SELECT array_agg(value ORDER BY value)
                                        FROM unnest(string_to_array(current_flow_element_data->>'value1', ',')) AS value
                                    ) != (
                                        SELECT array_agg(value ORDER BY value)
                                        FROM unnest(string_to_array(current_flow_element_data->>'value2', ',')) AS value
                                    ) THEN
                                   gateway_flow_element_next_true_id
                               ELSE
                                   gateway_flow_element_next_false_id
                               END
                       WHEN current_flow_element_data->>'comparison' = '>' THEN
                           CASE
                               WHEN current_flow_element_data->>'value1' > current_flow_element_data->>'value2' THEN
                                   gateway_flow_element_next_true_id
                               ELSE
                                   gateway_flow_element_next_false_id
                               END
                       WHEN current_flow_element_data->>'comparison' = '<' THEN
                           CASE
                               WHEN current_flow_element_data->>'value1' < current_flow_element_data->>'value2' THEN
                                   gateway_flow_element_next_true_id
                               ELSE
                                   gateway_flow_element_next_false_id
                               END
                       WHEN current_flow_element_data->>'comparison' = '>=' THEN
                           CASE
                               WHEN current_flow_element_data->>'value1' >= current_flow_element_data->>'value2' THEN
                                   gateway_flow_element_next_true_id
                               ELSE
                                   gateway_flow_element_next_false_id
                               END
                       WHEN current_flow_element_data->>'comparison' = '<=' THEN
                           CASE
                               WHEN current_flow_element_data->>'value1' <= current_flow_element_data->>'value2' THEN
                                   gateway_flow_element_next_true_id
                               ELSE
                                   gateway_flow_element_next_false_id
                               END
                       End INTO next_flow_element_id_first;

        WHEN current_flow_element_type = 'andSplitNode' THEN

            -- Get the next flow element ids from the and split flow element
            SELECT next_flow_element_id_1, next_flow_element_id_2 INTO next_flow_element_id_first, next_flow_element_id_second
            FROM and_split_element
            WHERE flow_element_id = NEW.instance_of;

        WHEN current_flow_element_type = 'endNode' THEN

            -- Don't get the next element id from the end node, instead set the process instance as completed if there is no active element left

            -- Check if there are any active flow element instances left
            IF NOT EXISTS (
                SELECT 1
                FROM flow_element_instance
                WHERE is_part_of = NEW.is_part_of
                  AND (status = 'Todo' OR status = 'In Progress' OR status = 'Created')
            ) THEN
                UPDATE process_instance
                SET status = 'Completed', completed_at = now()
                WHERE id = NEW.is_part_of;
            END IF;

            RETURN OLD;
        ELSE
            RAISE EXCEPTION 'Getting the next flow element id for the node type "%" is not implemented', current_flow_element_type;
        END CASE;

    -- Check if the any next flow element id is not null
    IF next_flow_element_id_first IS NULL AND next_flow_element_id_second IS NULL THEN
        RAISE EXCEPTION 'Next flow element id is null';
    END IF;

    -- Create the next flow element instance
    IF next_flow_element_id_first IS NOT NULL THEN
        INSERT INTO flow_element_instance (instance_of, is_part_of)
        VALUES (next_flow_element_id_first, NEW.is_part_of);
    END IF;

    -- Create the next flow element instance
    IF next_flow_element_id_second IS NOT NULL THEN
        INSERT INTO flow_element_instance (instance_of, is_part_of)
        VALUES (next_flow_element_id_second, NEW.is_part_of);
    END IF;

    RETURN OLD;
END;$function$
;

CREATE OR REPLACE FUNCTION public.execute_created_flow_element_instance()
    RETURNS trigger
    LANGUAGE plpgsql
AS $function$DECLARE
    flow_element_instance_execution_mode execution_mode;
    flow_element_instance_execution_url text;
    flow_element_data jsonb;
    flow_element_type text;
    app_url text;
    response text;
BEGIN

    -- Get the type of the flow element that is referenced
    SELECT type INTO flow_element_type
    FROM flow_element
    WHERE id = NEW.instance_of;

    -- If the type is 'startNode' or the status is not 'Created', then do nothing and return
    IF flow_element_type = 'startNode' OR NEW.status != 'Created' THEN
        RETURN OLD;
    END IF;

    IF flow_element_type = 'endNode' OR flow_element_type = 'gatewayNode' OR flow_element_type = 'andSplitNode' THEN
        UPDATE flow_element_instance
        SET status = 'Completed', completed_at = now()
        WHERE id = NEW.id;

        RETURN OLD;
    END IF;

    -- Get execution mode and execution url from the flow element
    SELECT nd.definition->>'executionMode' AS execution_mode, nd.definition->>'executionUrl' AS execution_url
    INTO flow_element_instance_execution_mode, flow_element_instance_execution_url
    FROM flow_element fe
             JOIN node_definition nd
                  ON (fe.data->>'nodeDefinitionId')::int8 = nd.id
    WHERE fe.id = NEW.instance_of;

    CASE
        -- Set status of instance to TO DO so a user can see it in their worklist
        WHEN flow_element_instance_execution_mode = 'Manual' THEN
            UPDATE flow_element_instance
            SET status = 'Todo'
            WHERE id = NEW.id;
        -- Execute instance and call the provided api url if it is automatic
        WHEN flow_element_instance_execution_mode = 'Automatic' THEN

            UPDATE flow_element_instance
            SET status = 'In Progress'
            WHERE id = NEW.id;

            -- TODO Fehler abfangen

            -- flow_element has a data column, which is a jsonb. This object is sent to the execution url
            SELECT data INTO flow_element_data
            FROM flow_element
            WHERE id = NEW.instance_of;

            flow_element_data := flow_element_data - array[
                'nodeDefinitionId',
                'assignedRole',
                'width',
                'height'
                ];

            -- Go through each value in the data object and replace any string with "{content}" with the content without the brackets
            -- The new values can be located in the data_object_instance table. The name col of the row is the value withoud the brackets
            flow_element_data := replace_with_variable_values(flow_element_data, NEW.is_part_of);

            SELECT value INTO app_url
            FROM config
            WHERE key = 'appUrl';

            PERFORM http_set_curlopt('CURLOPT_TCP_KEEPALIVE', '120');
            PERFORM http_set_curlopt('CURLOPT_CONNECTTIMEOUT', '120');
            PERFORM http_set_curlopt('CURLOPT_TIMEOUT', '120');

            BEGIN

                PERFORM http_post(
                        flow_element_instance_execution_url,
                        '{ "responsePath": "' || app_url || '/api/instance/complete"'
                            || ', "errorResponsePath": "' || app_url || '/api/instance/error"'
                            || ', "flowElementInstanceId": "' || NEW.id
                            || '", "data": ' || flow_element_data::text
                            || '}',
                        'application/json'
                        );
            EXCEPTION
                WHEN OTHERS THEN
                    PERFORM fail_flow_element_instance(NEW.id, 'Failed to execute flow element instance: ' || SQLERRM);
            END;
        ELSE
            RAISE EXCEPTION 'Not implemented scenario, where execution mode is "%"', flow_element_instance_execution_mode;
        END CASE;

    RETURN OLD;
END;$function$
;

CREATE OR REPLACE FUNCTION public.get_manual_tasks_with_replaced_data(team_id bigint, user_role_ids bigint[])
    RETURNS jsonb
    LANGUAGE plpgsql
AS $function$DECLARE
    tasks jsonb;
BEGIN
    -- Fetch the manual tasks with replaced data
    SELECT jsonb_agg(t)
    INTO tasks
    FROM (
             SELECT
                 id,
                 replaced_data AS data,
                 replaced_data->'task' AS name,
                 replaced_data->'description' AS description,
                 replaced_data->'outputs' AS outputs,
                 type,
                 status,
                 belongs_to,
                 created_at,
                 is_part_of,
                 instance_of,
                 completed_at,
                 assigned_role,
                 execution_url,
                 completed_by
             FROM manual_task,
                  LATERAL replace_with_variable_values(data, is_part_of) AS replaced_data
             WHERE belongs_to = team_id AND (assigned_role IS NOT NULL AND assigned_role <> '' AND assigned_role::bigint = ANY(user_role_ids))
         ) t;

    RETURN tasks;
END;$function$
;

create or replace view "public"."manual_task" as  SELECT flow_element_instance.id,
                                                         flow_element_instance.created_at,
                                                         flow_element_instance.instance_of,
                                                         flow_element_instance.status,
                                                         flow_element_instance.is_part_of,
                                                         flow_element_instance.completed_at,
                                                         flow_element_instance.completed_by,
                                                         process_model.belongs_to,
                                                         flow_element.type,
                                                         (node_definition.definition ->> 'executionUrl'::text) AS execution_url,
                                                         flow_element.data,
                                                         (flow_element.data ->> 'assignedRole'::text) AS assigned_role
                                                  FROM ((((flow_element_instance
                                                      JOIN flow_element ON ((flow_element_instance.instance_of = flow_element.id)))
                                                      JOIN process_instance ON ((flow_element_instance.is_part_of = process_instance.id)))
                                                      JOIN process_model ON ((process_instance.process_model_id = process_model.id)))
                                                      JOIN node_definition ON ((((flow_element.data ->> 'nodeDefinitionId'::text))::bigint = node_definition.id)))
                                                  WHERE ((node_definition.definition ->> 'executionMode'::text) = 'Manual'::text);


grant delete on table "public"."and_split_element" to "anon";

grant insert on table "public"."and_split_element" to "anon";

grant references on table "public"."and_split_element" to "anon";

grant select on table "public"."and_split_element" to "anon";

grant trigger on table "public"."and_split_element" to "anon";

grant truncate on table "public"."and_split_element" to "anon";

grant update on table "public"."and_split_element" to "anon";

grant delete on table "public"."and_split_element" to "authenticated";

grant insert on table "public"."and_split_element" to "authenticated";

grant references on table "public"."and_split_element" to "authenticated";

grant select on table "public"."and_split_element" to "authenticated";

grant trigger on table "public"."and_split_element" to "authenticated";

grant truncate on table "public"."and_split_element" to "authenticated";

grant update on table "public"."and_split_element" to "authenticated";

grant delete on table "public"."and_split_element" to "service_role";

grant insert on table "public"."and_split_element" to "service_role";

grant references on table "public"."and_split_element" to "service_role";

grant select on table "public"."and_split_element" to "service_role";

grant trigger on table "public"."and_split_element" to "service_role";

grant truncate on table "public"."and_split_element" to "service_role";

grant update on table "public"."and_split_element" to "service_role";

create policy "Allow for authenticated users"
    on "public"."and_split_element"
    as permissive
    for all
    to authenticated
    using (true);
